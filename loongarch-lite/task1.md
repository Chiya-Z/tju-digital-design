使用 C 语言，在框架代码的基础上，在 TEMU 目录中实现 loongarch32 的以下指令：

1. i12-type
    1. addi.w rd, rj, si12：将寄存器 rj 的值与立即数 si12 有符号扩展后的结果相加，结果存储到寄存器 rd 中。该指令不对溢出做任何处理。其编码格式为 0000001010 | si12[11:0] | rj[4:0] | rd[4:0]。
    2. ori rd, rj, ui12：将寄存器 rj 的值与立即数 ui12 零扩展后的结果按位逻辑或运算，结果存储到寄存器 rd 中。其编码格式为 0000001110 | ui12[11:0] | rj[4:0] | rd[4:0]。
    3. andi rd, rj, ui12：将寄存器 rj 的值与立即数 ui12 零扩展后的结果按位逻辑与运算，结果存储到寄存器 rd 中。其编码格式为 0000001101 | ui12[11:0] | rj[4:0] | rd[4:0]。
    4. st.w rd, rj, si12：将寄存器 rd 的值存储到以寄存器 rj 的值加上立即数 si12 有符号扩展后的结果作为地址的内存单元中。其编码格式为 0010100110 | si12[11:0] | rj[4:0] | rd[4:0]。
    5. ld.w rd, rj, si12：将以寄存器 rj 的值加上立即数 si12 有符号扩展后的结果作为地址的内存单元中的值加载到寄存器 rd 中。其编码格式为 0010100010 | si12[11:0] | rj[4:0] | rd[4:0]。
    6. st.b rd, rj, si12：将寄存器 rd 的最低字节存储到以寄存器 rj 的值加上立即数 si12 有符号扩展后的结果作为地址的内存单元中。其编码格式为 0010100100 | si12[11:0] | rj[4:0] | rd[4:0]。
    7. ld.b rd, rj, si12：将以寄存器 rj 的值加上立即数 si12 有符号扩展后的结果作为地址的内存单元中的最低字节加载到寄存器 rd 中，并对该字节进行有符号扩展。其编码格式为 0010100000 | si12[11:0] | rj[4:0] | rd[4:0]。
2. 3r-type
    1. add.w rd, rj, rk：将寄存器 rj 和寄存器 rk 的值相加，结果存储到寄存器 rd 中。该指令不对溢出做任何处理。其编码格式为 00000000000100000 | rk[4:0] | rj[4:0] | rd[4:0]。
    2. or rd, rj, rk：将寄存器 rj 和寄存器 rk 的值按位逻辑或运算，结果存储到寄存器 rd 中。其编码格式为 00000000000101010 | rk[4:0] | rj[4:0] | rd[4:0]。
    3. xor rd, rj, rk：将寄存器 rj 和寄存器 rk 的值按位逻辑异或运算，结果存储到寄存器 rd 中。其编码格式为 00000000000101011 | rk[4:0] | rj[4:0] | rd[4:0]。
    4. slt rd, rj, rk：将寄存器 rj 的值和寄存器 rk 的值进行有符号比较，如果 rj 小于 rk，则将 1 存储到寄存器 rd 中，否则存储 0。其编码格式为 00000000000100100 | rk[4:0] | rj[4:0] | rd[4:0]。
    5. srai.w rd, rj, ui5：将寄存器 rj 的值算术右移 ui5 位，结果存储到寄存器 rd 中。其编码格式为 000000000010010 | 001 | ui5[4:0] | rj[4:0] | rd[4:0]。
3. i20-type
    1. lu12i.w rd, si20：将立即数 si20 左移 12 位后存储到寄存器 rd 中。其编码格式为 0001010 | si20[19:0] | rd[4:0]。
    2. pcaddu12i rd, si20：将立即数 si20 左移 12 位后再有符号扩展到 32 位，并与该指令的 PC 相加，结果存储到寄存器 rd 中。其编码格式为 0001110 | si20[19:0] | rd[4:0]。
4. i16-type
    1. beq rj, rd, offs16：如果寄存器 rj 和寄存器 rd 的值相等，offs16 左移 2 位再有符号扩展到 32 位后，结果加到该指令的 PC 上，作为新的 PC。其编码格式为 010110 | offs16[15:0] | rj[4:0] | rd[4:0]。
    2. bne rj, rd, offs16：如果寄存器 rj 和寄存器 rd 的值不相等，offs16 左移 2 位再有符号扩展到 32 位后，结果加到该指令的 PC 上，作为新的 PC。其编码格式为 010111 | offs16[15:0] | rj[4:0] | rd[4:0]。
    3. bge rj, rd, offs16：将寄存器 rj 和寄存器 rd 的值进行有符号比较，如果 rj 大于等于 rd，则 offs16 左移 2 位再有符号扩展到 32 位后，结果加到该指令的 PC 上，作为新的 PC。其编码格式为 011001 | offs16[15:0] | rj[4:0] | rd[4:0]。


注意：

1. 当前环境无法运行仿真器，所以不要尝试运行代码，只需实现指令的功能即可。
2. 不要修改框架代码的逻辑。
3. 这是 32 位架构。
4. 采用小端字节序。
5. 在汇编中使用跳转指令时，如果采用直接填入偏移值的方式，则立即数应当以字节为单位，即 `offs16 << 2` 后的值应直接填入指令中。
6. 注意模块化实现。
